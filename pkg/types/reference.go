/*
 * SPDX-FileCopyrightText: 2020 SAP SE or an SAP affiliate company and Gardener contributors
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 */

package types

import (
	"github.com/gardener/controller-manager-library/pkg/controllermanager/cluster"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	"github.com/gardener/controller-manager-library/pkg/resources"
	"github.com/gardener/controller-manager-library/pkg/resources/errors"
)

// NewReferenceFrom creates an optimal type agnostic reference to a given object
// to be stored in another one
func NewReferenceFrom(obj metav1.Object, dst metav1.Object) ObjectReference {
	ns := dst.GetNamespace()
	if ns == obj.GetNamespace() {
		ns = ""
	}
	return ObjectReference{
		Name:      dst.GetName(),
		Namespace: ns,
	}
}

func NewReferenceByName(name string) ObjectReference {
	return ObjectReference{
		Name: name,
	}
}

// ObjectReference is is plain reference to an object of an implicitly determined type
type ObjectReference struct {
	Name string `json:"name"`
	// +optional
	Namespace string `json:"namespace,omitempty"`
	// +optional
	ClusterId string `json:"clusterId,omitempty"`
}

func (this *ObjectReference) RelativeTo(obj metav1.Object) resources.ObjectName {
	if this.Namespace == "" {
		return ObjectNameRelativeTo(this.Name, obj)
	}
	return resources.NewObjectName(this.Namespace, this.Namespace)
}

func (this *ObjectReference) ClusterKeyRelativeTo(obj resources.Object, gk schema.GroupKind) resources.ClusterObjectKey {
	id := this.ClusterId
	if id == "" {
		id = obj.GetCluster().GetId()
	}
	namespace := this.Namespace
	if namespace == "" {
		namespace = obj.GetNamespace()
	}
	return resources.NewClusterKey(id, gk, namespace, this.Name)
}

func (this *ObjectReference) ObjectName() resources.ObjectName {
	return resources.NewObjectName(this.Namespace, this.Name)
}

func (this *ObjectReference) GetRelativeTo(obj resources.Object, gk schema.GroupKind, clusters ...cluster.Clusters) (resources.Object, error) {
	var res resources.Resources
	if id := this.ClusterId; id == "" || id == obj.GetCluster().GetId() {
		res = obj.GetCluster().Resources()
	} else if len(clusters) == 1 {
		foreignCluster := clusters[0].GetById(this.ClusterId)
		if foreignCluster == nil {
			return nil, errors.ErrFailed.Newf([]interface{}{this.ClusterKeyRelativeTo(obj, gk)}, "foreign cluster not found: %s", this.ClusterId)
		}
		res = foreignCluster.Resources()
	} else {
		return nil, errors.ErrFailed.New(this.ClusterKeyRelativeTo(obj, gk), "foreign cluster not supported")
	}
	r, err := res.Get(gk)
	if err != nil {
		return nil, err
	}
	return r.Get(this.ObjectName())
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ObjectReference) DeepCopyInto(out *ObjectReference) {
	*out = *in
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ObjectReference.
func (in *ObjectReference) DeepCopy() *ObjectReference {
	if in == nil {
		return nil
	}
	out := new(ObjectReference)
	in.DeepCopyInto(out)
	return out
}

////////////////////////////////////////////////////////////////////////////////

func ObjectNameRelativeTo(name string, obj metav1.Object) resources.ObjectName {
	return resources.NewObjectName(obj.GetNamespace(), name)
}

func ClusterKeyRelativeTo(obj resources.Object, objname string, gk schema.GroupKind) resources.ClusterObjectKey {
	return resources.NewClusterKey(obj.GetCluster().GetId(), gk, obj.GetNamespace(), objname)
}
